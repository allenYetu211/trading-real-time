# WebSocketÂÆûÊó∂Êï∞ÊçÆÈõÜÊàêÊåáÂçó

**ÁâàÊú¨**: v1.0  
**Êó•Êúü**: 2025/07/20  
**WebSocket URL**: `ws://localhost:3000`

## üì° Ê¶ÇËø∞

Êú¨Á≥ªÁªüÊîØÊåÅÈÄöËøáWebSocketÊé•Êî∂ÂÆûÊó∂KÁ∫øÊï∞ÊçÆ„ÄÅ‰ª∑Ê†ºÊõ¥Êñ∞ÂíåÂàÜÊûêÁªìÊûú„ÄÇÂâçÁ´ØÂèØ‰ª•ÈÄöËøáËÆ¢ÈòÖÁõ∏Â∫îÁöÑÊï∞ÊçÆÊµÅÊù•Ëé∑ÂèñÂÆûÊó∂Êõ¥Êñ∞„ÄÇ

## üîó ËøûÊé•ÁÆ°ÁêÜ

### Âü∫Á°ÄËøûÊé•
```javascript
// Âª∫Á´ãWebSocketËøûÊé•
const ws = new WebSocket('ws://localhost:3000');

ws.onopen = function(event) {
    console.log('WebSocketËøûÊé•Â∑≤Âª∫Á´ã');
};

ws.onmessage = function(event) {
    const data = JSON.parse(event.data);
    console.log('Êî∂Âà∞Êï∞ÊçÆ:', data);
};

ws.onerror = function(error) {
    console.error('WebSocketÈîôËØØ:', error);
};

ws.onclose = function(event) {
    console.log('WebSocketËøûÊé•Â∑≤ÂÖ≥Èó≠');
    // ÂÆûÁé∞ÈáçËøûÈÄªËæë
    setTimeout(reconnect, 5000);
};
```

### È´òÁ∫ßËøûÊé•ÁÆ°ÁêÜ
```javascript
class TradingWebSocket {
    constructor(url = 'ws://localhost:3000') {
        this.url = url;
        this.ws = null;
        this.subscriptions = new Set();
        this.reconnectAttempts = 0;
        this.maxReconnectAttempts = 5;
        this.reconnectDelay = 1000;
        this.handlers = new Map();
    }
    
    connect() {
        return new Promise((resolve, reject) => {
            this.ws = new WebSocket(this.url);
            
            this.ws.onopen = (event) => {
                console.log('WebSocketËøûÊé•ÊàêÂäü');
                this.reconnectAttempts = 0;
                this.resubscribeAll();
                resolve(event);
            };
            
            this.ws.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    this.handleMessage(data);
                } catch (error) {
                    console.error('Ëß£ÊûêÊ∂àÊÅØÂ§±Ë¥•:', error);
                }
            };
            
            this.ws.onerror = (error) => {
                console.error('WebSocketÈîôËØØ:', error);
                reject(error);
            };
            
            this.ws.onclose = (event) => {
                console.log('WebSocketËøûÊé•ÂÖ≥Èó≠');
                this.attemptReconnect();
            };
        });
    }
    
    attemptReconnect() {
        if (this.reconnectAttempts < this.maxReconnectAttempts) {
            this.reconnectAttempts++;
            console.log(`Â∞ùËØïÈáçËøû (${this.reconnectAttempts}/${this.maxReconnectAttempts})`);
            
            setTimeout(() => {
                this.connect();
            }, this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1));
        } else {
            console.error('ÈáçËøûÂ§±Ë¥•ÔºåÂ∑≤ËææÂà∞ÊúÄÂ§ßÈáçËØïÊ¨°Êï∞');
        }
    }
    
    subscribe(type, symbol, interval, handler) {
        const subscription = `${type}:${symbol}:${interval}`;
        this.subscriptions.add(subscription);
        this.handlers.set(subscription, handler);
        
        if (this.ws && this.ws.readyState === WebSocket.OPEN) {
            this.sendSubscription(type, symbol, interval);
        }
    }
    
    unsubscribe(type, symbol, interval) {
        const subscription = `${type}:${symbol}:${interval}`;
        this.subscriptions.delete(subscription);
        this.handlers.delete(subscription);
        
        if (this.ws && this.ws.readyState === WebSocket.OPEN) {
            this.sendUnsubscription(type, symbol, interval);
        }
    }
    
    sendSubscription(type, symbol, interval) {
        const message = {
            action: 'subscribe',
            type: type,
            symbol: symbol,
            interval: interval
        };
        this.send(message);
    }
    
    sendUnsubscription(type, symbol, interval) {
        const message = {
            action: 'unsubscribe',
            type: type,
            symbol: symbol,
            interval: interval
        };
        this.send(message);
    }
    
    resubscribeAll() {
        for (const subscription of this.subscriptions) {
            const [type, symbol, interval] = subscription.split(':');
            this.sendSubscription(type, symbol, interval);
        }
    }
    
    handleMessage(data) {
        if (data.type && data.symbol && data.interval) {
            const subscription = `${data.type}:${data.symbol}:${data.interval}`;
            const handler = this.handlers.get(subscription);
            
            if (handler) {
                handler(data);
            }
        }
    }
    
    send(message) {
        if (this.ws && this.ws.readyState === WebSocket.OPEN) {
            this.ws.send(JSON.stringify(message));
        }
    }
    
    close() {
        if (this.ws) {
            this.ws.close();
        }
    }
}
```

## üìä Êï∞ÊçÆÁ±ªÂûã

### KÁ∫øÊï∞ÊçÆÊµÅ
```javascript
// ËÆ¢ÈòÖKÁ∫øÊï∞ÊçÆ
ws.subscribe('kline', 'BTCUSDT', '1h', (data) => {
    console.log('KÁ∫øÊõ¥Êñ∞:', data);
    /*
    {
        type: 'kline',
        symbol: 'BTCUSDT',
        interval: '1h',
        data: {
            openTime: 1640995200000,
            closeTime: 1640998799999,
            open: '46000.00',
            high: '46500.00',
            low: '45800.00',
            close: '46200.00',
            volume: '125.25',
            isFinal: false  // ÊòØÂê¶ÊòØÂÆåÊàêÁöÑKÁ∫ø
        }
    }
    */
});
```

### ‰ª∑Ê†ºÊõ¥Êñ∞ÊµÅ
```javascript
// ËÆ¢ÈòÖ‰ª∑Ê†ºÊõ¥Êñ∞
ws.subscribe('ticker', 'BTCUSDT', '', (data) => {
    console.log('‰ª∑Ê†ºÊõ¥Êñ∞:', data);
    /*
    {
        type: 'ticker',
        symbol: 'BTCUSDT',
        data: {
            price: 46250.75,
            change: 250.75,
            changePercent: 0.55,
            timestamp: 1640995200000
        }
    }
    */
});
```

### ÂàÜÊûêÁªìÊûúÊµÅ
```javascript
// ËÆ¢ÈòÖÂàÜÊûêÁªìÊûú
ws.subscribe('analysis', 'BTCUSDT', '1h', (data) => {
    console.log('ÂàÜÊûêÊõ¥Êñ∞:', data);
    /*
    {
        type: 'analysis',
        symbol: 'BTCUSDT',
        interval: '1h',
        data: {
            signal: 'BUY',
            confidence: 0.72,
            trend: 0.65,
            momentum: 0.78,
            patterns: ['BREAKOUT'],
            timestamp: 1640995200000
        }
    }
    */
});
```

## üéØ ÂÆûÈôÖÂ∫îÁî®Á§∫‰æã

### ReactÁªÑ‰ª∂Á§∫‰æã
```jsx
import React, { useState, useEffect, useRef } from 'react';

function TradingDashboard() {
    const [prices, setPrices] = useState(new Map());
    const [signals, setSignals] = useState(new Map());
    const [klineData, setKlineData] = useState(new Map());
    const wsRef = useRef(null);
    
    useEffect(() => {
        // ÂàùÂßãÂåñWebSocketËøûÊé•
        wsRef.current = new TradingWebSocket();
        
        wsRef.current.connect().then(() => {
            // ËÆ¢ÈòÖ‰ª∑Ê†ºÊï∞ÊçÆ
            wsRef.current.subscribe('ticker', 'BTCUSDT', '', (data) => {
                setPrices(prev => new Map(prev.set(data.symbol, data.data)));
            });
            
            // ËÆ¢ÈòÖÂàÜÊûê‰ø°Âè∑
            wsRef.current.subscribe('analysis', 'BTCUSDT', '1h', (data) => {
                setSignals(prev => new Map(prev.set(`${data.symbol}_${data.interval}`, data.data)));
            });
            
            // ËÆ¢ÈòÖKÁ∫øÊï∞ÊçÆ
            wsRef.current.subscribe('kline', 'BTCUSDT', '1h', (data) => {
                if (data.data.isFinal) {
                    setKlineData(prev => {
                        const key = `${data.symbol}_${data.interval}`;
                        const existing = prev.get(key) || [];
                        return new Map(prev.set(key, [...existing.slice(-99), data.data]));
                    });
                }
            });
        });
        
        return () => {
            if (wsRef.current) {
                wsRef.current.close();
            }
        };
    }, []);
    
    const btcPrice = prices.get('BTCUSDT');
    const btcSignal = signals.get('BTCUSDT_1h');
    
    return (
        <div className="trading-dashboard">
            <div className="price-section">
                <h3>BTC‰ª∑Ê†º</h3>
                {btcPrice && (
                    <div>
                        <div className="price">${btcPrice.price}</div>
                        <div className={`change ${btcPrice.change >= 0 ? 'positive' : 'negative'}`}>
                            {btcPrice.change >= 0 ? '+' : ''}{btcPrice.change} ({btcPrice.changePercent}%)
                        </div>
                    </div>
                )}
            </div>
            
            <div className="signal-section">
                <h3>‰∫§Êòì‰ø°Âè∑</h3>
                {btcSignal && (
                    <div>
                        <div className={`signal ${btcSignal.signal.toLowerCase()}`}>
                            {btcSignal.signal}
                        </div>
                        <div className="confidence">
                            ÁΩÆ‰ø°Â∫¶: {(btcSignal.confidence * 100).toFixed(1)}%
                        </div>
                    </div>
                )}
            </div>
        </div>
    );
}
```

### VueÁªÑ‰ª∂Á§∫‰æã
```vue
<template>
  <div class="trading-dashboard">
    <div class="price-section">
      <h3>{{ symbol }}‰ª∑Ê†º</h3>
      <div v-if="priceData" class="price-info">
        <div class="price">${{ priceData.price }}</div>
        <div :class="['change', priceData.change >= 0 ? 'positive' : 'negative']">
          {{ priceData.change >= 0 ? '+' : '' }}{{ priceData.change }} 
          ({{ priceData.changePercent }}%)
        </div>
      </div>
    </div>
    
    <div class="signal-section">
      <h3>‰∫§Êòì‰ø°Âè∑</h3>
      <div v-if="signalData" class="signal-info">
        <div :class="['signal', signalData.signal.toLowerCase()]">
          {{ signalData.signal }}
        </div>
        <div class="confidence">
          ÁΩÆ‰ø°Â∫¶: {{ (signalData.confidence * 100).toFixed(1) }}%
        </div>
      </div>
    </div>
  </div>
</template>

<script>
export default {
  name: 'TradingDashboard',
  data() {
    return {
      symbol: 'BTCUSDT',
      interval: '1h',
      priceData: null,
      signalData: null,
      ws: null
    };
  },
  
  async mounted() {
    await this.initWebSocket();
  },
  
  beforeUnmount() {
    if (this.ws) {
      this.ws.close();
    }
  },
  
  methods: {
    async initWebSocket() {
      this.ws = new TradingWebSocket();
      
      try {
        await this.ws.connect();
        
        // ËÆ¢ÈòÖ‰ª∑Ê†ºÊï∞ÊçÆ
        this.ws.subscribe('ticker', this.symbol, '', (data) => {
          this.priceData = data.data;
        });
        
        // ËÆ¢ÈòÖÂàÜÊûê‰ø°Âè∑
        this.ws.subscribe('analysis', this.symbol, this.interval, (data) => {
          this.signalData = data.data;
        });
        
      } catch (error) {
        console.error('WebSocketËøûÊé•Â§±Ë¥•:', error);
      }
    }
  }
};
</script>
```

## üîß ÊúÄ‰Ω≥ÂÆûË∑µ

### 1. ËøûÊé•ÁÆ°ÁêÜ
```javascript
// ÂÆûÁé∞ÂøÉË∑≥Êú∫Âà∂
class TradingWebSocketWithHeartbeat extends TradingWebSocket {
    constructor(url) {
        super(url);
        this.heartbeatInterval = null;
        this.heartbeatTimeout = null;
    }
    
    connect() {
        return super.connect().then(() => {
            this.startHeartbeat();
        });
    }
    
    startHeartbeat() {
        this.heartbeatInterval = setInterval(() => {
            if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                this.ws.send(JSON.stringify({action: 'ping'}));
                
                this.heartbeatTimeout = setTimeout(() => {
                    console.warn('ÂøÉË∑≥Ë∂ÖÊó∂ÔºåÈáçËøû...');
                    this.ws.close();
                }, 10000);
            }
        }, 30000);
    }
    
    handleMessage(data) {
        if (data.action === 'pong') {
            clearTimeout(this.heartbeatTimeout);
            return;
        }
        
        super.handleMessage(data);
    }
    
    close() {
        if (this.heartbeatInterval) {
            clearInterval(this.heartbeatInterval);
        }
        if (this.heartbeatTimeout) {
            clearTimeout(this.heartbeatTimeout);
        }
        super.close();
    }
}
```

### 2. Êï∞ÊçÆÂ§ÑÁêÜ‰ºòÂåñ
```javascript
// Èò≤ÊäñÂ§ÑÁêÜÈ´òÈ¢ëÊï∞ÊçÆ
function createThrottledHandler(handler, delay = 100) {
    let lastCall = 0;
    let timeout = null;
    
    return function(data) {
        const now = Date.now();
        
        if (now - lastCall >= delay) {
            lastCall = now;
            handler(data);
        } else {
            clearTimeout(timeout);
            timeout = setTimeout(() => {
                lastCall = Date.now();
                handler(data);
            }, delay - (now - lastCall));
        }
    };
}

// ‰ΩøÁî®Á§∫‰æã
const throttledPriceHandler = createThrottledHandler((data) => {
    updatePriceDisplay(data);
}, 200);

ws.subscribe('ticker', 'BTCUSDT', '', throttledPriceHandler);
```

### 3. ÈîôËØØÂ§ÑÁêÜ
```javascript
// Áªü‰∏ÄÈîôËØØÂ§ÑÁêÜ
class ErrorHandler {
    static handleWebSocketError(error, symbol, interval) {
        console.error(`WebSocketÈîôËØØ [${symbol}/${interval}]:`, error);
        
        // ËÆ∞ÂΩïÈîôËØØ
        this.logError({
            type: 'websocket_error',
            symbol,
            interval,
            error: error.message,
            timestamp: Date.now()
        });
        
        // ÈÄöÁü•Áî®Êà∑
        this.notifyUser(`${symbol} Êï∞ÊçÆËøûÊé•ÂºÇÂ∏∏ÔºåÊ≠£Âú®ÈáçËØï...`);
    }
    
    static logError(errorInfo) {
        // ÂèëÈÄÅÈîôËØØÊó•ÂøóÂà∞ÊúçÂä°Âô®
        fetch('/api/logs/error', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(errorInfo)
        });
    }
    
    static notifyUser(message) {
        // ÊòæÁ§∫Áî®Êà∑ÈÄöÁü•
        console.warn(message);
        // Êàñ‰ΩøÁî®‰Ω†ÁöÑÈÄöÁü•ÁªÑ‰ª∂
    }
}
```

## üìã Ë∞ÉËØïÊäÄÂ∑ß

### 1. ËøûÊé•Áä∂ÊÄÅÁõëÊéß
```javascript
function monitorWebSocketStatus(ws) {
    const statusDiv = document.getElementById('ws-status');
    
    function updateStatus(status, color) {
        statusDiv.textContent = status;
        statusDiv.style.color = color;
    }
    
    ws.addEventListener('open', () => updateStatus('Â∑≤ËøûÊé•', 'green'));
    ws.addEventListener('close', () => updateStatus('Â∑≤Êñ≠ÂºÄ', 'red'));
    ws.addEventListener('error', () => updateStatus('ËøûÊé•ÈîôËØØ', 'orange'));
}
```

### 2. Ê∂àÊÅØÊó•Âøó
```javascript
function logWebSocketMessages(ws) {
    const originalSend = ws.send;
    
    ws.send = function(data) {
        console.log('ÂèëÈÄÅÊ∂àÊÅØ:', data);
        return originalSend.call(this, data);
    };
    
    ws.addEventListener('message', (event) => {
        console.log('Êé•Êî∂Ê∂àÊÅØ:', event.data);
    });
}
```

### 3. ÊÄßËÉΩÁõëÊéß
```javascript
class PerformanceMonitor {
    constructor() {
        this.messageCount = 0;
        this.startTime = Date.now();
        this.lastMessageTime = 0;
    }
    
    onMessage(data) {
        this.messageCount++;
        const now = Date.now();
        const latency = now - this.lastMessageTime;
        this.lastMessageTime = now;
        
        if (this.messageCount % 100 === 0) {
            const duration = (now - this.startTime) / 1000;
            const rate = this.messageCount / duration;
            
            console.log(`Ê∂àÊÅØÁªüËÆ°: ${this.messageCount}Êù°, ÈÄüÁéá: ${rate.toFixed(2)}/Áßí, Âª∂Ëøü: ${latency}ms`);
        }
    }
}
```

## üöÄ Âø´ÈÄüÂºÄÂßã

1. **Âü∫Á°ÄÈõÜÊàê**
```javascript
// ÊúÄÁÆÄÂçïÁöÑÈõÜÊàêÊñπÂºè
const ws = new TradingWebSocket();
await ws.connect();

// ËÆ¢ÈòÖBTC‰ª∑Ê†º
ws.subscribe('ticker', 'BTCUSDT', '', (data) => {
    console.log('BTC‰ª∑Ê†º:', data.data.price);
});

// ËÆ¢ÈòÖ‰∫§Êòì‰ø°Âè∑
ws.subscribe('analysis', 'BTCUSDT', '1h', (data) => {
    console.log('‰∫§Êòì‰ø°Âè∑:', data.data.signal);
});
```

2. **ÊµãËØïËøûÊé•**
```bash
# ‰ΩøÁî®wscatÊµãËØïWebSocketËøûÊé•
npm install -g wscat
wscat -c ws://localhost:3000

# ÂèëÈÄÅËÆ¢ÈòÖÊ∂àÊÅØ
{"action":"subscribe","type":"ticker","symbol":"BTCUSDT","interval":""}
```

---

**Ê≥®ÊÑè**: WebSocketËøûÊé•ÈúÄË¶ÅÂêéÁ´ØÊúçÂä°ÊîØÊåÅÔºåÁ°Æ‰øùÊúçÂä°Á´ØÂ∑≤ÂêØÂä®Âπ∂Ê≠£Á°ÆÈÖçÁΩÆWebSocketÂäüËÉΩ„ÄÇ 